# Code-Fest-2025
Watch our demo: https://youtu.be/ytofVzWLzoE

## Run the Project

To launch the Code-Fest 2025 application locally:

1. **Clone the repository** and open it in your preferred code editor.

2. In one terminal, start the **backend**:
   ```bash
   cd backend
   uvicorn main:app --reload

3. In another terminal, start the **frontend**:
   ```bash
   cd frontend
   npm run dev

4. Use the local host generated by the frontend to view UI,

   
## 🗂️ Repository Structure

| Folder | Purpose |
|---------|----------|
| **/backend** | Holds our FastAPI application which integrates with our frontend LLM. |
| **/data/** | Shared and stored data sets. Tracks the YelpFusion API, open street map, and open trip map data. Our main files used for processing through our application include: hotels_nyc_geocoded.csv, restaurants_near_hotels.csv, hotel_recommendations.csv, and hotel_scores_with_recos.csv. This data collected is used in relation with our score_model_v2.py to efficiently recommend the optimal hotel and restaurants. |
| **/frontend/** | Connects the backend and our score model to display and execute the travel survey. The user input is run through our score model and based on their preferences, the output will recommend the top 5 hotels along with the top 5 restaurants. Our LLM is implemented at this stage and generates a friendly response for travelers.   
| **/images/** | Holds our system, data and scoring flow, and deployment diagrams.  |
| **/notes/** | Jupyter NoteBooks with data retrieval and cleaning, as well as our final score model.  |
| **README.md** | Main documentation (project overview, architecture, and how to run). |

## 🏗️ Architecture Overview

Below are the three key diagrams that describe the system’s design.

### 1️⃣ System Diagram
<p align="center">
  <img src="images/Deployment_view_diagram.svg" width="650" alt="System Diagram">
</p>

### 2️⃣ Data & Scoring Flow
<p align="center">
  <img src="images/data_and_scoring_flow.svg" width="650" alt="Data & Scoring Flow">
</p>

### 3️⃣ Deployment Overview
<p align="center">
  <img src="images/high_level_diagram.svg" width="650" alt="Deployment Overview">
</p>

---

### 🧱 Modularity & Composability
 **Layers:** UI (React) → API (FastAPI) → Data (Local CSV Files) → Model (`scoring_model.py`)
- **Design:** Each layer is isolated — frontend handles presentation, backend handles logic, and the model runs scoring separately.
- **Reusable components:** CSV outputs and data loaders can be swapped for future APIs or database integrations.
- **Organization:**  
  `/data/` → clean inputs/outputs  
  `/images/` → architecture diagrams  
  `/notes/` → API + model logic  

---

### ⚙️ Technology Choices
- **Frontend:** React + Vite (lightweight, modular, responsive)  
- **Backend:** FastAPI (Python 3, async, type-safe, easy to deploy)  
- **External API:** Yelp Fusion API (real restaurant data)  
- **Data Storage:** Local CSV files in `/data` (easy to update and version control)  
- **Environment:** `.env` for secrets and config variables 

---

### 🔐 Security
- API key for yelp data stored in `.env` → never exposed to frontend  
- Input validated with **Pydantic** models in FastAPI  
- **CORS** limited to approved frontend origin   
- **HTTPS** enforced when deployed  

---

### ⚡ Scalability
- **Stateless** FastAPI backend (easy horizontal scaling)  
- **Batch processing** for scoring model → fast API lookups  
- **Pagination** & **top-K results** limit payload size  
- Can be scaled to handle **larger datasets** (more hotels, more cities)  
- Future option: connect to a **cloud database** or add **Redis cache** for efficiency  
- Designed for deployment on **Render / Railway / Docker**

---

### 📡 Data / Content Flow
- The system uses **local CSV datasets** stored in the `/data/` folder instead of a live database.  
- All data is **pre-cleaned and batch processed** by `scoring_model.py`, producing:  
  - `hotel_scores_with_recos.csv` → aggregated hotel scores  
  - `hotel_recommendations.csv` → top-K restaurant recommendations per hotel  
- The **FastAPI backend** loads these pre-computed files and serves results directly to the UI.  
- The current design can easily extend to a **cloud database** or **real-time updates** in future versions

---

### 🎨 AX / CX / UI
- **User flow:**  
  1. Select preferences (radius, price, cuisines, weights)  
  2. View ranked hotels  
  3. Expand a hotel → see top-5 restaurant recommendations  
- **Design focus:** Clear cards, icons for distance/rating, simple slider inputs  
- **Error handling:** Empty-state messages & loading skeletons for better UX  

---

The backend reads from pre-computed CSVs in `/data/` and exposes simple JSON routes:
### 🧪 API Routes (File-Based)
```text
GET  /api/hotels/top?limit=5
GET  /api/hotels/{hotel_id}/restaurants?top_k=5
POST /api/score/preview   # body: { radius_m, price_levels, cuisines, weights }
GET  /health
```

---

### 🗂️ Data Management
- Source data for hotels and restaurants is stored in `/data/`.  
- Each CSV can be replaced or extended without code changes.  
- Outputs from the scoring model are saved back into `/data/` for reuse.  
- This design keeps the system **lightweight, portable, and reproducible**.

---

---

## 🧮 The Model

The model ranks restaurants near each hotel using a weighted scoring formula:

``restaurant_score(r) = w_d s_dist + w_r s_rating + w_p s_pricefit + w_c s_cuisine``

where:  

- **d** = distance in meters between the hotel and restaurant  
- **r₁⁄₂** = "half-life" distance from user’s preferred radius  
- **s_dist = exp(−ln 2 × d_meters / r₁⁄₂)**  
  - starts at 1 when distance = 0  
  - drops to 0.5 at half-life distance  
  - decays exponentially beyond that, reflecting diminishing sensitivity to distance  
- **s_rating = (yelp rating) / 5**  
  - normalized rating (0–1 range); defaults to 0 if missing  
- **s_price fit** maps price levels: `$`→1, `$$`→2, `$$$`→3 …  
  - if restaurant’s level is within user’s allowed range → 1, else 0  
- **s_cuisine = 1** if any liked cuisine appears in the restaurant’s categories (case-insensitive), else 0  

Weights *(w_d, w_r, w_p, w_c)* come from user sliders and must sum to 1.

---


---

### ⚙️ Model Application

For each hotel:
1. The model evaluates all nearby restaurants and computes `score_r` ∈ [0, 1] using the formula above.  
2. Restaurants are sorted in descending order by `score_r`.  
3. The **hotel score** is calculated as the mean of its top 5 restaurant scores:

\[
hotel score = mean(top 5 restaurant scores)
\]

This generates:
- `hotel_scores_with_recos.csv` → one row per hotel, aggregated scores  
- `hotel_recommendations.csv` → top-K (usually 5) restaurants per hotel
